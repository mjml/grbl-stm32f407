Notes for stepper.stm32.[ch]:

The structures:

typedef struct st_block_t: This is execution data for a "block", or a linear move in any number of axes.
st_block_t st_block_buffer[SEGMENT_BUFFER_SIZE-1]: The entire block buffer

typedef struct segment_t: This is the unit of a ring buffer that stores short line segments. These represent
segments of a linear move. Once "checked out" they are a commitment to that motion and cannot be modified.

typedef struct stepper_t: Keeps running data for the stepper service routine. This includes counters for the Bresenham algo,
  some flags, timing counters, bit fields for pulse and dir pins, step counter, and pointers to the current block and segment.

Semantic change: all of the .xxx_yyybits fields are now just indexed by motor AXIS (x=0, y=1, ... etc). 
                 As opposed to their direct pin values in AVR. This is due to the addition of the gpio_t layer in STM32.

typedef struct st_prep_t: Encapsulation struct for computing new segments from the currently executing block.


The functions:

st_wake_up(): This simply enables the stepper pins, then starts the stepper driver interrupt timer.
  Under arduino, this is TIM1. We need to commit to a timer and configuration for this purpose under STM32.

st_go_idle(): The complementary function to st_wake_up(), this immediately disables the timer interrupt and 
  resets the associated prescaler.

ISR(TIMER1_COMPA_vect): The stepper driver timer interrupt. Much written in the comments. 
  The Bresenham algorithm is "keyed" on the timer interrupt.
  There are a few places where this function touches hardware:
    - The DIRECTION_PORT pins are set first
    - The STEP_PORT pulse pins are set next
    In STEP_PULSE_DELAY, only the direction pins are set, the pulse pins are set in TIMER0_COMPA_vect, 
    In either configuration (with delay or without) the dir and pulse pins are cleared in TIMER0_OVF_vect.
    So STEP_PULSE_DELAY enforces a contrained lead time for the dir pin before pulses are sent.

    - TCNT0 is set to the pulse time (this seems to be a up-counter that triggers the port reset.)
    - TCCR0B <= (1<<CS01) enables the timer/counter

    Outside of AMASS, the timer prescaler is used to provide increased resolution for the non-dominant axes, this results in
      a faster ISR call (but with denominators on the axes themselves). This call has to be completely re-engineered as it 
      uses Arduino prescaler constants.
      - TCCR1B = (TCCR1B & ~(0x07 << CS10)) | st.exec_segment->prescaler << CS10)

    - OCR1A = st.exec_segment->cycles_per_tick sets the time to the next TIMER1 overflow (ISR).


ISR(TIMER0_OVF_vect): The stepper "port reset" interrupt. Handles the falling edges of the step pulse.
    - STEP_PORT pins are cleared
    - TCCR0B = 0 disables the port reset timer (this is essentially a repeated one-shot style timer counter)
    
    In ENABLE_DUAL_AXIS, we also set STEP_PORT_DUAL bits


In STEP_PULSE_DELAY, we use another ISR on TIMER0_COMPA to set the st.step_bits high.


st_reset(): Resets all stepper subsystem variables and states to an initial state.
    STEP_PORT and DIRECTION_PORT pins are fully cleared (and inverted if necessary).


stepper_init():
    STEP_DDR |= STEP_MASK: Sets the stepper pins to output mode.
    STEPPERS_DISABLE_DDR |= (1<<STEPPERS_DISABLE_BIT): They seem to assign pin B0 to indicate disabling ~all~ steppers.
    
    Configure Timer1: The main stepper pulse interrupt
    TCCR1B &= ~(1<<WGM13); // waveform generation
    TCCR1B |=  (1<<WGM12); 
    TCCR1A &= ~((1<<WGM10) | (1<<WGM10));
    TCCR1A &= ~((1<<COM1A1) | (1<<COM1A0) | (1<<COM1B1) | (1<<COM1B0)); // Disconnect OC1 output

    Configure Timer0: The stepper pulse (set and) reset interrupt
    TIMSK0 &= ~((1<<OCIE0B) | (1<<OCIE0A) | (1<<TOIE0)); // Disconnect OC0 outputs and OVF interrupt
    TCCR0A = 0; // Normal operation
    TCCR0B = 0; // Disable Timer0 (until needed)
    TIMSK0 |= (1<<TOIE0); // Enable Timer0 overflow interrupt


st_update_plan_block_parameters(): called by planner_recalculate when the executing block is updated.


st_next_block_index(uint8_t block_index): this is just an incrementer modulo SEGMENT_BUFFER_SIZE.


st_parking_setup_buffer(): In PARKING_ENABLE, this method adjusts the current segment buffer to execute the park.


st_parking_restore_buffer(): In PARKING_ENABLE, this method restores the step segment buffer to the normal run state after a park.


st_prep_buffer(): This lengthy method is called from the main program.
    Tentative explanation: this method is a staging method for taking the velocity profiles (blocks) generated by the planner and 
      converting those into a more direct queue of stepper instructions (segments).
    
    There's not much hardware interaction to see here, it's mostly the bridging logic between the coarser planning steps 
      and the linear segments.


Summary: The challenge to porting is that several of the state variables for pins and ports are specified as bytefields
    since in the Arduino setting all the stepper/dir/etc pins are on a common port.
    
    So we'll have to visit some of the statevars in the segment structure (and maybe the block structure) and either convert
    their values to set/reset calls to STM32 GPIO HAL, or change the semantics of the variables so that they are organized
    according to the AXIS variables defined by our new gpio_map module. 

    Either way, the code needs to be altered so that the unpacking of the Bresenham segments and their execution,
        a) sets the dir and pul pins properly
        b) sets up the main pulse timer and the secondary pulse reset timer properly
        c) sets the step counts accurately during segment execution
        d) sets the prescaler properly for non-AMASS, or (... ? ...) during AMASS
        e) enables timers clears STEPPERS_DISABLE_PORT during _wake_up()
        f) disables timers and sets the STEPPERS_DISABLE_PORT during _go_idle()
